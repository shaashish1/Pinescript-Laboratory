//@version=4
study("Forecasting: Holt’s Damped Linear Trend Forecasting", '', true, precision=2)

// author: capissimo
// This is a continuation of my previous post on Holt's Linear Trend Forecasting.

// The forecasts generated by Holt’s linear method display a constant trend 
// (increasing or decreasing) indefinitely into the future. 
// Empirical evidence indicates that these methods tend to over-forecast, 
// especially for longer forecast horizons. Motivated by this observation, 
// Gardner & McKenzie (1985) introduced a parameter that “dampens” the trend to a 
// flat line some time in the future. Methods that include a damped trend have 
// proven to be very successful, and are arguably the most popular individual 
// methods when forecasts are required automatically for many series.

// In conjunction with the smoothing parameters alpha and beta (with values between 0 and 1 
// as in Holt’s method), this method also includes a damping parameter 0 < phi (ϕ) < 1:

// Forecast equation: ŷ = l + (phi + phi^2 + ... + phi^h) * b 
// Level equation: l = alpha * y + (1 - alpha) * (l[1] + phi * b[1]) 
// Trend equation: b = beta * (l - l[1]) + (1 - beta) * phi * b[1] 

// If phi=1, the method is identical to Holt’s linear method. 
// For values between 0 and 1, phi dampens the trend so that it 
// approaches a constant some time in the future. In fact, the forecasts 
// converge to lT + phi * bT/(1 - phi) as h → ∞ for any value 0< phi <1. 
// This means that short-run forecasts are trended while long-run forecasts are constant.
// In practice, phi is rarely less than 0.8 as the damping has a very strong effect 
// for smaller values. Values of phi close to 1 will mean that a damped model is not 
// able to be distinguished from a non-damped model. For these reasons, we usually 
// restrict phi to a minimum of 0.8 and a maximum of 0.98.

//*** Functions
holtd(y, al, bt, ph, p) => // Holt's damped method
    l = 0.0, b = 0.0, f = 0.0
    l := al * y + (1-al) * (nz(l[1]) + ph * nz(b[1]))  // level 
    b := bt * (l-l[1]) + (1-bt) * ph * nz(b[1])        // trend 
    d = 0.0
    for i=1 to p  // (phi + phi^2 + ... + phi^h)
        d := d + pow(ph, i)
	f := nz(l[1]) + d * nz(b[1])                       // forecast
    [l, b, f]
	
//*** Inputs
price = input(close, "Price Data")
alpha = input(0.4,   "Slope (alpha)",    minval=0.000001, step=0.001)
beta  = input(0.75,  "Intercept (beta)", minval=0.000001, step=0.001)
phi   = input(0.8,   "Dampening Factor (best=0.80-0.98)", minval=0.1, maxval=1., step=0.01)
per   = input(6,     "Forecasted Periods")

//*** Main
[l, b, f] = holtd(price, alpha, beta, phi, per)

var line fl = na
line.delete(fl[1])
fl := line.new(time, close, time + 60 * 60 * 24 * per, f, 
               xloc.bar_time, extend=extend.none, style=line.style_solid, color=color.orange, width=2)
